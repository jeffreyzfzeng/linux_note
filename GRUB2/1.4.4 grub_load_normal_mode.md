# grub\_load\_normal\_mode

We come to the last routine invoked in `grub_main`, before loading normal mode module, let's first check all loaded modules now, because more grub modules will be loaded in order to load it. `print_all_modules` is a function added in gdb script.

```c
(gdb) print_all_modules 
$1 = 0x7ff8fd0 "search_fs_uuid"
$2 = (void (*)(struct grub_dl *)) 0x7ff8977
$3 = 0x7ffa0a0 "biosdisk"
$4 = (void (*)(struct grub_dl *)) 0x7ff9929
$5 = 0x7ffa920 "part_msdos"
$6 = (void (*)(struct grub_dl *)) 0x7ffa558
$7 = 0x7ffbe30 "ext2"
$8 = (void (*)(struct grub_dl *)) 0x7ffb629
$9 = 0x7ffc990 "fshelp"
$10 = (void (*)(struct grub_dl *)) 0x0
```

# _load normal mode module_

`grub_load_normal_mode` invokes `grub_dl_load` with module name `normal` to load the module.

`grub_dl_load` gets directory of modules located:

```c
  "(hd0,msdos1)/boot/grub"
```

get the accurate path of normal module:

```c
  "(hd0,msdos1)/boot/grub/i386-pc/normal.mod"
```

load the module file with routine `grub_dl_load_file`, after procedure of `grub_dl_load_file`completed, normal module loaded completed.

```c
grub-core/kern/dl.c:704

/* Load a module using a symbolic name.  */
grub_dl_t
grub_dl_load (const char *name)
{
  char *filename;
  grub_dl_t mod;
  const char *grub_dl_dir = grub_env_get ("prefix");
(gdb) p grub_dl_dir
$11 = 0x7ff8030 "(hd0,msdos1)/boot/grub"

  mod = grub_dl_get (name);
  if (mod)
gdb) p mod
$12 = (grub_dl_t) 0x0
    return mod;

  ......

  filename = grub_xasprintf ("%s/" GRUB_TARGET_CPU "-" GRUB_PLATFORM "/%s.mod",
                             grub_dl_dir, name);
  if (! filename)
(gdb) p filename
$14 = 0x7ff7f20 "(hd0,msdos1)/boot/grub/i386-pc/normal.mod"
    return 0;

  mod = grub_dl_load_file (filename);
(gdb) p mod
$15 = (grub_dl_t) 0x7ff7ee0
  grub_free (filename);

  ......
}
```

Now let's check all loaded modules again, not only normal modules, but also some others for example `boot, extcmd, crypto, terminal, gettext, gzio`  were loaded as well.

```c
(gdb) print_all_modules 
$17 = 0x7ff7ec0 "normal"
$18 = (void (*)(struct grub_dl *)) 0x7f06c68
$19 = 0x7f02bf0 "gzio"
$20 = (void (*)(struct grub_dl *)) 0x7f00199
$21 = 0x7ff30d0 "gettext"
$22 = (void (*)(struct grub_dl *)) 0x7ff2692
$23 = 0x7ff42c0 "terminal"
$24 = (void (*)(struct grub_dl *)) 0x7ff39c6
$25 = 0x7ff5c50 "crypto"
$26 = (void (*)(struct grub_dl *)) 0x0
$27 = 0x7ff70a0 "extcmd"
$28 = (void (*)(struct grub_dl *)) 0x0
$29 = 0x7ff7d50 "boot"
$30 = (void (*)(struct grub_dl *)) 0x7ff77ca
$31 = 0x7ff8fd0 "search_fs_uuid"
$32 = (void (*)(struct grub_dl *)) 0x7ff8977
$33 = 0x7ffa0a0 "biosdisk"
$34 = (void (*)(struct grub_dl *)) 0x7ff9929
$35 = 0x7ffa920 "part_msdos"
$36 = (void (*)(struct grub_dl *)) 0x7ffa558
$37 = 0x7ffbe30 "ext2"
$38 = (void (*)(struct grub_dl *)) 0x7ffb629
$39 = 0x7ffc990 "fshelp"
$40 = (void (*)(struct grub_dl *)) 0x0
```

# _about procedure of loading a module from the file FILENAME_

In order to make clear why so many new modules loaded, let's go back to routine `grub_dl_load_file`.

`grub_dl_load_file` opens normal mode module on disk with `grub_file_open`.

```c
grub-core/kern/dl.c:662

/* Load a module from the file FILENAME.  */
grub_dl_t
grub_dl_load_file (const char *filename)
{

  ......

  file = grub_file_open (filename);
  if (! file)
    return 0;

  ......

}
```

`grub_file_open` divides device name and file name first

```c
grub_file_t
grub_file_open (const char *name)
{
  ......
  
  device_name = grub_file_get_device_name (name);
  if (grub_errno)
    goto fail;

  /* Get the file part of NAME.  */
  file_name = (name[0] == '(') ? grub_strchr (name, ')') : NULL;
  if (file_name)
    file_name++;
  else
    file_name = (char *) name;
  
  ......

}
```

opens device with `grub_device_open`

```c
grub_file_t
grub_file_open (const char *name)
{
  ......

  device = grub_device_open (device_name);
  grub_free (device_name);
  if (! device)
    goto fail;
  
  ......

}
```

inside `grub_device_open` it invokes `grub_disk_open` with device name as its input parameter

```c
grub_device_t
grub_device_open (const char *name)
{
  ......
  
  dev->disk = grub_disk_open (name);
  
  ......
  
}
```

`grub_disk_open` finds name of disk

```c
grub_disk_t
grub_disk_open (const char *name)
{
  ......
  
  p = find_part_sep (name);
  if (p)
    {
      grub_size_t len = p - name;

      raw = grub_malloc (len + 1);
      if (! raw)
    goto fail;

      grub_memcpy (raw, name, len);
      raw[len] = '\0';
      disk->name = grub_strdup (raw);
    }

  ......
  
}
```

`grub_disk_open`opens the device with the routine supplied by `biosdisk` module as in current loaded module, only this module is for disk devide's purpose and only one item in `grub_disk_dev_list` at this stage.

```c
grub_disk_t
grub_disk_open (const char *name)
{
  ......
  
  for (dev = grub_disk_dev_list; dev; dev = dev->next)
    {
      if ((dev->open) (raw, disk) == GRUB_ERR_NONE)
    break;
      else if (grub_errno == GRUB_ERR_UNKNOWN_DEVICE)
    grub_errno = GRUB_ERR_NONE;
      else
    goto fail;
    }
  
  ......
  
}
```

gets partition information with grub\_partition\_probe with disk and partition name as its input parameter

```c
grub_disk_t
grub_disk_open (const char *name)
{
  ......
  
  if (p)
    {
      disk->partition = grub_partition_probe (disk, p + 1);
      if (! disk->partition)
    {
      /* TRANSLATORS: It means that the specified partition e.g.
         hd0,msdos1=/dev/sda1 doesn't exist.  */
      grub_error (GRUB_ERR_UNKNOWN_DEVICE, N_("no such partition"));
      goto fail;
    }
  }
  
  ......

}
```

`grub_partition_probe` converts partition name to number with type unsigned long

```c
grub_partition_t
grub_partition_probe (struct grub_disk *disk, const char *str)
{
  ......

      num = grub_strtoul (ptr, (char **) &ptr, 0) - 1;
  
  ......
  
}
```

before get parition information information, first find a partition map type

```c
grub_partition_t
grub_partition_probe (struct grub_disk *disk, const char *str)
{
  ......

      /* Use the first partition map type found.  */
      FOR_PARTITION_MAPS(partmap)
      {
	if (partname_end != partname &&
	    (grub_strncmp (partmap->name, partname, partname_end - partname)
	     != 0 || partmap->name[partname_end - partname] != 0))
	  continue;

	disk->partition = part;
	curpart = grub_partition_map_probe (partmap, disk, num);
	disk->partition = tail;
	if (curpart)
	  break;

	if (grub_errno == GRUB_ERR_BAD_PART_TABLE)
	  {
	    /* Continue to next partition map type.  */
	    grub_errno = GRUB_ERR_NONE;
	    continue;
	  }

	break;
      }

  ......

}
```

the defination of `FOR_PARTITION_MAPS(partmap)` as follow, it loops all types of partition map, here we only has one type of partion map type, it is msdos.

```c
#define FOR_PARTITION_MAPS(var) FOR_LIST_ELEMENTS((var), (grub_partition_map_list))

and 

#define FOR_LIST_ELEMENTS(var, list) for ((var) = (list); (var); (var) = (var)->next)
```

get partition information by routine `grub_partition_map_probe` with partition map type found, disk and number converted from partition name as its input parameters.

OK, after partition information got completed, disk open and device open are completed soon, go back to routine `grub_file_open`



