# grub\_load\_normal\_mode second half

`grub_dl_resolve_symbols` resoloves symbols of the module. It finds the section with symbos table included.

```c
static grub_err_t
grub_dl_resolve_symbols (grub_dl_t mod, Elf_Ehdr *e)
{

  ......

  for (i = 0, s = (Elf_Shdr *) ((char *) e + e->e_shoff);
       i < e->e_shnum;
       i++, s = (Elf_Shdr *) ((char *) s + e->e_shentsize))
    if (s->sh_type == SHT_SYMTAB)
      break;

  ......

}
```

after allocates memory for symbols table in module data, resolves symbols of the module.

Initialize and finalize function of the module are resolved in this procedure as well.

```c
static grub_err_t
grub_dl_resolve_symbols (grub_dl_t mod, Elf_Ehdr *e)
{
  ......

    for (i = 0;
       i < size / entsize;
       i++, sym = (Elf_Sym *) ((char *) sym + entsize))
    {
      unsigned char type = ELF_ST_TYPE (sym->st_info);
      unsigned char bind = ELF_ST_BIND (sym->st_info);
      const char *name = str + sym->st_name;

      switch (type)
    {

    ......

      if (grub_strcmp (name, "grub_mod_init") == 0)
        mod->init = (void (*) (grub_dl_t)) sym->st_value;
      else if (grub_strcmp (name, "grub_mod_fini") == 0)
        mod->fini = (void (*) (void)) sym->st_value;
      break;

       ......

    }
    }

  ......
}
```

`grub_arch_dl_relocate_symbols` relocates symbols base on hardware architecture. DIfferent archtectures has its own implementation of this routine.

After above prepartion done, initializes module with routine `grub_dl_call_init`.

```c
static void
grub_dl_call_init (grub_dl_t mod)
{
  if (mod->init)
    (mod->init) (mod);
}
```

Every module implements init and finl functions by following style

```c
GRUB_MOD_INIT(module_name)
{
  ......
}

GRUB_MOD_FINI(module_name)
{
  ......
}
```

For the detail implementation of normal mode module initialization, it will be discussed later, let's complete the procedure of `grub_load_normal_mode`, this subject opened too long time.

Add the module to `grub_dl_head` with routine `grub_dl_add` once initialization done. The procedure of `grub_dl_load_core` completed, soon go back to `grub_load_normal_mode` and an entire procedure of loading a specific module has similar approach, take the normal mode module as a reference.

# _execute command "normal"_

The last routine invoked in `grub_load_normal_mode`:

```c
static void
grub_load_normal_mode (void)
{
  ......

  grub_command_execute ("normal", 0, 0);
}
```

the normal command is registered in normal module initialization. If no failure in linux boot, normal command isn't executed at all.

```c
GRUB_MOD_INIT(normal)
{
  ......

  /* Register a command "normal" for the rescue mode.  */
  grub_register_command ("normal", grub_cmd_normal,
			 0, N_("Enter normal mode."));

  .......
}
```

For the detail of normal command, please check code offline.

About linux boot failure in grub 2, references the material at the end of this chapter.

# _Links_

* [Repair Linux boot failures in GRUB 2 rescue mode](https://www.howtoforge.com/tutorial/repair-linux-boot-with-grub-rescue/)



