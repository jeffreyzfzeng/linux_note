grub_main: grub_load_modules
==============================================================================================================

Ahead grub_load_modules, we ignore some of grub functions, the functions are not important to learning grub.

```Hello
grub-core/kern/main.c:213

  /* Hello.  */
  grub_setcolorstate (GRUB_TERM_COLOR_HIGHLIGHT);
  grub_printf ("Welcome to GRUB!\n\n");
  grub_setcolorstate (GRUB_TERM_COLOR_STANDARD);
```
Above 3 functions print Welcome to GRUB! on console.
![](/assets/Welcome to GRUB!.png)

```register_symbols
grub-core/kern/main.c:218

  /* Load pre-loaded modules and free the space.  */
  grub_register_exported_symbols ();
```

Function grub_register_exported_symbols could be found in grub-core/symlist.c, symlist.c is automatically generated by gensymlist.sh when compiling gurb source code. Inside grub_register_exported_symbols, it calculates a hash key value based on the name of specific symbol and saves the symbol information to a simple hash table: grub_symtab.


All loaded modules stored in grub_dl_head, it's a global variable. Before executing grub_load_modules, no modules stored in it, after load first module successfully, check it again, we can find fshelp stored in it. GRUB consists of several images: a variety of bootstrap images for starting GRUB in various ways, a kernel image, and a set of modules which are combined with the kernel image to form a core image, what grub_load_modules do is load modules included in core image.

The startup address of modules stored in grub_modbase. grub_load_modules involves grub_dl_load_core to load single module, inside grub_dl_load_core, it allocates memory for mode information, load module segments and resolve symbols for specific modules, if initialization function exists, calls the init function for mode initialization, finally adds mode information to global variable grub_dl_head.

```grub_load_modules
grub-core/kern/main.c:50

/* Load all modules in core.  */
static void
grub_load_modules (void)
{
  struct grub_module_header *header;
  FOR_MODULES (header)
  {
(gdb) p grub_dl_head
$1 = (grub_dl_t) 0x0
    /* Not an ELF module, skip.  */
    if (header->type != OBJ_TYPE_ELF)
      continue;

    if (! grub_dl_load_core ((char *) header + sizeof (struct grub_module_header),
                             (header->size - sizeof (struct grub_module_header))))
      grub_fatal ("%s", grub_errmsg);
(gdb) p grub_errno 
$2 = GRUB_ERR_NONE
(gdb) p grub_dl_head->name
$4 = 0x7ffc990 "fshelp"
    if (grub_errno)
      grub_print_error ();
  }
}

-------------------------------------------------------------------------------------------------------------
All modules after loaded as follow, after load normal module, there will be more modules loaded.

(gdb) print_all_modules 
$1 = 0x7ff8fd0 "search_fs_uuid"
$2 = (void (*)(struct grub_dl *)) 0x7ff8977
$3 = 0x7ffa0a0 "biosdisk"
$4 = (void (*)(struct grub_dl *)) 0x7ff9929
$5 = 0x7ffa920 "part_msdos"
$6 = (void (*)(struct grub_dl *)) 0x7ffa558
$7 = 0x7ffbe30 "ext2"
$8 = (void (*)(struct grub_dl *)) 0x7ffb629
$9 = 0x7ffc990 "fshelp"
$10 = (void (*)(struct grub_dl *)) 0x0
-------------------------------------------------------------------------------------------------------------

grub-core/kern/dl.c:594

/* Load a module from core memory.  */
grub_dl_t
grub_dl_load_core (void *addr, grub_size_t size)
{
  Elf_Ehdr *e;
  grub_dl_t mod;

  grub_dprintf ("modules", "module at %p, size 0x%lx\n", addr,
                (unsigned long) size);
  e = addr;
  if (grub_dl_check_header (e, size))
    return 0;

  if (e->e_type != ET_REL)
    {
      grub_error (GRUB_ERR_BAD_MODULE, N_("this ELF file is not of the right type"));
      return 0;
    }

  /* Make sure that every section is within the core.  */
  if (size < e->e_shoff + e->e_shentsize * e->e_shnum)
    {
      grub_error (GRUB_ERR_BAD_OS, "ELF sections outside core");
      return 0;
    }

  mod = (grub_dl_t) grub_zalloc (sizeof (*mod));
  if (! mod)
    return 0;

  mod->ref_count = 1;

  grub_dprintf ("modules", "relocating to %p\n", mod);
  /* Me, Vladimir Serbinenko, hereby I add this module check as per new
     GNU module policy. Note that this license check is informative only.
     Modules have to be licensed under GPLv3 or GPLv3+ (optionally
     multi-licensed under other licences as well) independently of the
     presence of this check and solely by linking (module loading in GRUB
     constitutes linking) and GRUB core being licensed under GPLv3+.
     Be sure to understand your license obligations.
  */
  if (grub_dl_check_license (e)
      || grub_dl_resolve_name (mod, e)
      || grub_dl_resolve_dependencies (mod, e)
      || grub_dl_load_segments (mod, e)
      || grub_dl_resolve_symbols (mod, e)
      || grub_arch_dl_relocate_symbols (mod, e))
    {
      mod->fini = 0;
      grub_dl_unload (mod);
      return 0;
    }

  grub_dl_flush_cache (mod);

  grub_dprintf ("modules", "module name: %s\n", mod->name);
  grub_dprintf ("modules", "init function: %p\n", mod->init);
  grub_dl_call_init (mod);

  if (grub_dl_add (mod))
    {
      grub_dl_unload (mod);
      return 0;
    }

  return mod;
}

```